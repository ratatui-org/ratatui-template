---
title: "`main.rs`"
---

In this section, let's just cover the contents of `main.rs`, `build.rs` and `utils.rs`.

The `main.rs` file is the entry point of the application. Here's the complete file:

```rust
use anyhow::Result;
use clap::Parser;
use ratatui_template::{
  app::App,
  utils::{initialize_logging, initialize_panic_handler, version},
};

// Define the command line arguments structure
#[derive(Parser, Debug)]
#[command(version = version(), about = "ratatui template with crossterm and tokio")]
struct Args {
  /// App tick rate
  #[arg(short, long, default_value_t = 1000)]
  app_tick_rate: u64,
  /// Render tick rate
  #[arg(short, long, default_value_t = 50)]
  render_tick_rate: u64,
}

// Main function
#[tokio::main]
async fn main() -> Result<()> {
  initialize_logging()?;

  initialize_panic_handler();

  let args = Args::parse();
  let tick_rate = (args.app_tick_rate, args.render_tick_rate);

  let mut app = App::new(tick_rate)?;
  app.run().await?;

  Ok(())
}
```

In essence, the `main` function creates an instance of `App` and calls `app.run()`, which runs the "draw update loop".
We will talk more about this in a later section.

This `main.rs` file incorporates three key features that are not necessarily related to Terminal User Interfaces, but in my opinion, essential for any Terminal User Interface (TUI) program:

### Command Line Argument Parsing (`clap`)

In this file, we define a [`clap`](https://docs.rs/clap/latest/clap/) `Args` struct.
This allows us to pass command line arguments to our terminal user interface if we need to.

![](https://user-images.githubusercontent.com/1813121/252718163-ab1945d1-7d44-4b5b-928d-1164ac99f2c9.png)

In addtion to command line arguments, we typically want the version of the command line program to show up on request. In the `clap` command, we pass in an argument called `version()`.
This `version()` function (defined in `src/utils.rs`) uses a environment variable called `RATATUI_TEMPLATE_GIT_INFO` to get the version number with the git commit hash.
`RATATUI_TEMPLATE_GIT_INFO` is populated in `./build.rs` when building with `cargo`.

![](https://user-images.githubusercontent.com/1813121/252718003-b9b24daf-8bfd-428b-adc3-4a9e2a5b7376.png)

You can configure what the version string should look like by modifying the string template code in `utils::version()`.

### XDG Base Directory Specification

Most command line tools have configuration files or data files that they need to store somewhere.
To be a good citizen, you might want to consider following the XDG Base Directory Specification.

This template uses `directories-rs` and `ProjectDirs`'s config and data local directories.
You can find more information about the exact location for your operating system here: <https://github.com/dirs-dev/directories-rs#projectdirs>.

This template also prints out the location when you pass in the `--version` command line argument.

![](https://user-images.githubusercontent.com/1813121/252721469-4d5ec38b-e868-46b4-b7b7-1c2c8bc496ac.png)

There are situations where you or your users may want to override where the configuration and data files should be located.
This can be accomplished by using the environment variables `RATATUI_TEMPLATE_CONFIG` and `RATATUI_TEMPLATE_DATA`.

The functions that calculate the config and data directories are in `src/utils.rs`.
Feel free to modify the `utils::get_config_dir()` and `utils::get_data_dir()` functions as you see fit.

### Logging

The `utils::initialize_logging()` function is also defined in `src/utils.rs`.
The log level is decided by the `RUST_LOG` environment variable (default = `log::LevelFilter::Info`).
In addition, the location of the log files are decided by the `RATATUI_TEMPLATE_DATA` environment variable (default = `XDG_DATA_HOME (local)`).

I tend to use `.envrc` and `direnv` for development purposes, and I have the following in my `.envrc`:

```bash
export RATATUI_TEMPLATE_CONFIG=`pwd`/.config
export RATATUI_TEMPLATE_DATA=`pwd`/.data
export RUST_LOG=debug
```

This puts the log files in the `RATATUI_TEMPLATE_DATA` folder, i.e. `.data` folder in the current directory, and sets the log level to `RUST_LOG`, i.e. `debug` when I am prototyping and developing using `cargo run`.

![](https://user-images.githubusercontent.com/1813121/252722210-0ba65d74-12d7-4908-a02b-53778feea183.png)

Using the `RATATUI_TEMPLATE_CONFIG` environment variable also allows me to have configuration data that I can use for testing when development that doesn't affect my local user configuration for the same program.

### Panic Handler

Finally `initialize_panic_handler()`, which is also in `src/utils.rs`, is used to define a callback when the application panics.
Your application may panic for a number of reasons (e.g. when you call `.unwrap()` on a `None`).
And you want to:

a) Provide a useful stacktrace so that they can report errors back to you.
b) Be a good citizen and not leave the users terminal state in a botched condition, resetting it back to the way it was.

`utils::initialize_panic_handler()` uses [`better_panic`](https://docs.rs/better-panic/latest/better_panic/) to provide a prettier backtrace by default.

In the screenshot below, I added a `None.unwrap()` into a function that is called on a keypress, so that you can see what a prettier backtrace looks like:

![](https://user-images.githubusercontent.com/1813121/252723080-18c15640-c75f-42b3-8aeb-d4e6ce323430.png)

`utils::initialize_panic_handler()` also calls `TerminalHandler::new().exit()` to reset the terminal state back to the way it was before the user started the TUI program.
We'll learn more about the `TerminalHandler` in the next sections.
