---
title: "`app.rs`"
---

Finally, putting all the pieces together, we are almost ready to get the `App` struct.
Before we do, we should discuss the process of a TUI.

Most TUIs are single process, single threaded applications.

```svgbob
 ,-------------.
 |Get Key Event|
 `-----+-------'
       |
       |
 ,-----v------.
 |Update State|
 `-----+------'
       |
       |
   ,---v---.
   | Draw  |
   `-------'
```

When an application is structured like this, the TUI is blocking at each step:

1. Waiting for a Event.
  - If no key or mouse event in 250ms, send `Tick`.
2. Update the state of the app based on `event` or `action`.
3. `draw` the state of the app to the terminal using `ratatui`.

This works perfectly fine for small applications, and this is what I recommend starting out with.
For _most_ TUIs, you'll never need to graduate from this process methodology.

Usually, `draw` and `getting key events` are fast enough that it doesn't matter.
But if you do need to do a computationally demanding or I/O intensive task while updating state (e.g. reading a database, computing math or making a web request), your app may "hang" while it is doing so.

Let's say a user presses `j` to scroll down a list.
And every time the user presses `j` you want to check the web for additional items to add to the list.

What should happen when a user presses and holds `j`?
It is up to you to decide how you would like your TUI application to behave in that instance.

You may decide that the desired behavior for your app is to hang while downloading new elements for the list, and all key presses while the app hangs are received and handled "instantly" after the download completes.

Alternatively, you may decide you want the app to update in the background, and a user should be able to scroll through the existing list while the app is downloading new elements.

In my experience, the trade-off is here is usually complexity for the developer vs ergonomics for the user.

Let's say we weren't worried about complexity, and were interested in performing a computationally demanding or I/O intensive task in the background.
And let's also say we were interested in showing an indicator that a task is running in the background.

One way to handle this is we add more `Action` elements.
A key press should trigger `Action::StartDownloadInBackground`.
And when the download is complete `Action::DownloadComplete` should be dispatched.

This means that we'll have to start a "task" when dispatching on `Action::StartDownloadInBackground` and send a `Action::DownloadComplete` from that "task" when it is completed.

In order to do this, we'll have to use a channel that can send and receive `Action`s, and use this channel in different parts of our application, i.e.:

```rust
loop {
  tokio::select! {
    event = event_rx.recv() => {
      let action = home.lock().await.handle_events(event);
      action_tx.send(action).unwrap();
    }
  }
}
```

Let's update our `EventHandler` to take a reference to the `Home` component and a `Action` channel sender instance.
After a little refactoring, this is what it looks like:

```rust
pub struct EventHandler {
  pub task: JoinHandle<()>,
  cancellation_token: CancellationToken,
}

impl EventHandler {
  pub fn new( tick_rate: (u64, u64), home: Arc<Mutex<Home>>, action_tx: mpsc::UnboundedSender<Action>) -> Self {
    let (app_tick_rate, render_tick_rate) = tick_rate;

    let (event_tx, mut event_rx) = mpsc::unbounded_channel();

    let app_tick_rate = std::time::Duration::from_millis(app_tick_rate);
    let render_tick_rate = std::time::Duration::from_millis(render_tick_rate);

    let cancellation_token = CancellationToken::new();
    let _cancellation_token = cancellation_token.clone();
    let task = tokio::spawn(async move {
      let mut reader = crossterm::event::EventStream::new();
      let mut app_interval = tokio::time::interval(app_tick_rate);
      let mut render_interval = tokio::time::interval(render_tick_rate);
      loop {
        let app_delay = app_interval.tick();
        let render_delay = render_interval.tick();
        let crossterm_event = reader.next().fuse();
        tokio::select! {
          _ = _cancellation_token.cancelled() => {
            break;
          }
          maybe_event = crossterm_event => {
            match maybe_event {
              Some(Ok(evt)) => {
                match evt {
                  CrosstermEvent::Key(key) => {
                    if key.kind == KeyEventKind::Press {
                      event_tx.send(Event::Key(key)).unwrap();
                    }
                  },
                  CrosstermEvent::Resize(x, y) => {
                    event_tx.send(Event::Resize(x, y)).unwrap();
                  },
                  _ => {},
                }
              }
              Some(Err(_)) => {
                event_tx.send(Event::Error).unwrap();
              }
              None => {},
            }
          },
          _ = app_delay => {
              event_tx.send(Event::AppTick).unwrap();
          },
          _ = render_delay => {
              event_tx.send(Event::RenderTick).unwrap();
          },
          event = event_rx.recv() => {
            let action = home.lock().await.handle_events(event);
            action_tx.send(action).unwrap();
          }
        }
      }
    });
    Self { task, cancellation_token }
  }

  pub fn stop(&mut self) {
    self.cancellation_token.cancel();
  }
}
```

In the `main` thread, any `Action` received on the `Action` channel is passed to `home.dispatch(action)` to update the state of the app.

```rust
loop {
  if let Some(action) = action_rx.recv().await; {
    match action {
      Action::RenderTick => tui.render(),
      Action::Quit => self.should_quit = true,
      _ => {
        self.home.lock().await.dispatch(action);
      },
    }
  }

  if self.should_quit {
    break;
  }
}
```

```svgbob
+--------------------------------------------------------------------------------+
| tokio::spawn                                                                   |
|                                                                                |
|   +-----------------------------+                                              |
|   | (loop)                      |                                              |
|   | - Event::Quit               |----> Action::Quit                            |
|   | - Event::RenderTick         |----> Action::RenderTick ( Message::Render )  |
|   | - Event::AppTick            |----> Action::Tick                            |
|   | - Event::Key(KeyEvent)      |----> home.handle_key_event(evt)              |
|   | - ...                       |                                              |
|   +-----------------------------+                                              |
|                                                                                |
+--------------------------------------------------------------------------------+
```

Now that we have those two tasks set up, we can create a `app.rs` like so:

```rust
pub struct App {
  pub tick_rate: (u64, u64),
  pub home: Arc<Mutex<Home>>,
  pub should_quit: bool,
  pub should_suspend: bool,
}

impl App {
  pub fn new(tick_rate: (u64, u64)) -> Result<Self> {
    let home = Arc::new(Mutex::new(Home::new()));
    Ok(Self { tick_rate, home, should_quit: false, should_suspend: false })
  }

  pub async fn run(&mut self) -> Result<()> {
    let (action_tx, mut action_rx) = mpsc::unbounded_channel();

    self.home.lock().await.action_tx = Some(action_tx.clone());

    self.home.lock().await.init()?;

    let mut terminal = TerminalHandler::new(self.home.clone());
    let mut event = EventHandler::new(self.home.clone(), self.tick_rate, action_tx.clone());

    loop {
      if let Some(action) = action_rx.recv().await {
        if action != Action::Tick {
          trace_dbg!(action);
        }
        match action {
          Action::RenderTick => terminal.render()?,
          Action::Quit => self.should_quit = true,
          Action::Suspend => self.should_suspend = true,
          Action::Resume => self.should_suspend = false,
          _ => {
            if let Some(_action) = self.home.lock().await.dispatch(action) {
              action_tx.send(_action)?
            };
          },
        }
      }
      if self.should_suspend {
        terminal.suspend()?;
        event.stop();
        terminal.task.await?;
        event.task.await?;
        terminal = TerminalHandler::new(self.home.clone());
        event = EventHandler::new(self.home.clone(), self.tick_rate, action_tx.clone());
        action_tx.send(Action::Resume)?;
      } else if self.should_quit {
        terminal.stop()?;
        event.stop();
        terminal.task.await?;
        event.task.await?;
        break;
      }
    }
    Ok(())
  }
}
```

We use the `dispatch` function to take an `Action` and modify the state of `Home` or any of the sub components.
