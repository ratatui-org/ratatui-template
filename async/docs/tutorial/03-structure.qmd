---
title: "`event.rs`"
---

Here's the `EventHandler` code:

```rust
use anyhow::Result;
use crossterm::{
  cursor,
  event::{DisableMouseCapture, EnableMouseCapture, Event as CrosstermEvent, KeyEvent, KeyEventKind, MouseEvent},
  terminal::{EnterAlternateScreen, LeaveAlternateScreen},
};
use futures::{FutureExt, StreamExt};
use tokio::{
  sync::{mpsc, oneshot},
  task::JoinHandle,
};

#[derive(Clone, Copy, Debug)]
pub enum Event {
  Quit,
  Error,
  Closed,
  RenderTick,
  AppTick,
  Key(KeyEvent),
  Mouse(MouseEvent),
  Resize(u16, u16),
}

#[derive(Debug)]
pub struct EventHandler {
  _tx: mpsc::UnboundedSender<Event>,
  rx: mpsc::UnboundedReceiver<Event>,
  stop_tx: Option<oneshot::Sender<()>>,
  task: Option<JoinHandle<()>>,
}

impl EventHandler {
  pub fn new(app_tick_rate: u64, render_tick_rate: u64) -> Self {
    let app_tick_rate = std::time::Duration::from_millis(app_tick_rate);
    let render_tick_rate = std::time::Duration::from_millis(render_tick_rate);

    let (tx, rx) = mpsc::unbounded_channel();
    let _tx = tx.clone();

    let (stop_tx, mut stop_rx) = oneshot::channel::<()>();

    let task = tokio::spawn(async move {
      let mut reader = crossterm::event::EventStream::new();
      let mut app_interval = tokio::time::interval(app_tick_rate);
      let mut render_interval = tokio::time::interval(render_tick_rate);
      loop {
        let app_delay = app_interval.tick();
        let render_delay = render_interval.tick();
        let crossterm_event = reader.next().fuse();
        if stop_rx.try_recv().ok().is_some() {
          break;
        }
        tokio::select! {
          maybe_event = crossterm_event => {
            match maybe_event {
              Some(Ok(evt)) => {
                match evt {
                  CrosstermEvent::Key(key) => {
                    if key.kind == KeyEventKind::Press {
                      tx.send(Event::Key(key)).unwrap();
                    }
                  },
                  CrosstermEvent::Resize(x, y) => {
                    tx.send(Event::Resize(x, y)).unwrap();
                  },
                  _ => {},
                }
              }
              Some(Err(_)) => {
                tx.send(Event::Error).unwrap();
              }
              None => {},
            }
          },
          _ = app_delay => {
              tx.send(Event::AppTick).unwrap();
          },
          _ = render_delay => {
              tx.send(Event::RenderTick).unwrap();
          },
        }
      }
    });

    Self { _tx, rx, stop_tx: Some(stop_tx), task: Some(task) }
  }

  pub async fn next(&mut self) -> Option<Event> {
    self.rx.recv().await
  }

  pub async fn stop(&mut self) -> Result<()> {
    if let Some(stop_tx) = self.stop_tx.take() {
      stop_tx.send(()).unwrap()
    }
    if let Some(handle) = self.task.take() {
      handle.await.unwrap()
    }
    Ok(())
  }
}
```

### Explanation

All terminal user interfaces have at the very least one main loop.
In our example, this is the `run_app` function:

```rust
fn render_app(frame: &mut Frame<CrosstermBackend<Stdout>>) {
  let greeting = Paragraph::new("Hello World! (press 'q' to quit)");
  frame.render_widget(greeting, frame.size());
}

fn run_app(terminal: &mut Terminal<CrosstermBackend<Stdout>>) -> Result<()> {
  loop {
    terminal.draw(|f| render_app(f))?;
  }
  Ok(())
}
```

The instance of the `ratatui::Terminal` struct has a `draw` method that takes an argument that implements `FnOnce`^[FnOnce is a trait in Rust that represents a function pointer/closure that can be called exactly once and may consume the variables it captures.].

The `render_app` function that we pass in takes a reference to `ratatui::Frame` and we can use that frame to draw to it.
`ratatui` then uses the content of `Frame` to decide how it wants to render the contents to the terminal^[`ratatui` uses a double frame painting method, i.e. it keeps a reference to the old frame and the current frame in memory. When drawing, it compares the two frames and only inserts the characters in screen buffer where there are differences. This is the most efficient way to do it because it minimizes IO writes. This is an implementation detail of `ratatui` and is not necessarily something we need to be concerned about.].

While we are in the "raw mode", i.e. after we call `enable_raw_mode()`, any key presses in that terminal window are sent to `stdin`.
We have to read these key presses from `stdin` if we want to act on them.

There's a number of different ways to do that.
`crossterm` has a `event` module that implements features to read these key presses for us.
We will use that to call `poll` and if the `q` key is pressed we will exit.

```rust
fn render_app(...) {
  ...
}

fn should_quit() -> Result<bool> {
  if event::poll(Duration::from_millis(250))? {
    if let Event::Key(key) = event::read()? {
      return Ok(KeyCode::Char('q') == key.code);
    }
  }
  Ok(false)
}

fn run_app(terminal: &mut Terminal<CrosstermBackend<Stdout>>) -> Result<()> {
  loop {
    terminal.draw(|f| render_app(f))?;
    if should_quit()? {
      break;
    }
  }
  Ok(())
}
```

When we `break` out of `run_app`'s `loop`, as we saw in the `main` function, we end up calling `restore_terminal()` which resets the terminal state back to what it was before we started the application.

There you have it, the very basics of getting a TUI up and running.

In the previous section, we had a function called `should_quit` that used `crossterm::event::poll()` and `event::read()` to decide when we want to quit.

In real world apps, we may have a lot more key events that we want to act on.
For example, if we wanted to add a vertical scroll bar, we might want change the state of the scrollbar like this:

```rust {source-line-numbers="9-14" .numberLines}
fn run_app(terminal: &mut Terminal<CrosstermBackend<Stdout>>, mut app: App) -> Result<()> {
  let mut last_tick = Instant::now();
  loop {
    terminal.draw(|f| render_app(f))?;
    if event::poll(timeout)? {
      if let Event::Key(key) = event::read()? {
        match key.code {
          KeyCode::Char('q') => return Ok(()),
          KeyCode::Char('j') => {
            app.vertical_scroll = app.vertical_scroll.saturating_add(1);
            app.vertical_scroll_state = app
              .vertical_scroll_state
              .position(app.vertical_scroll);
          }
          KeyCode::Char('k') => {
            app.vertical_scroll = app.vertical_scroll.saturating_sub(1);
            app.vertical_scroll_state = app
              .vertical_scroll_state
              .position(app.vertical_scroll);
          }
          _ => {}
        }
      }
    }
  }
```

But in addition to changing the state of the scroll bar, we may also want to do additional things (e.g. scroll down a table).
This code could get more complicated.
We may even want key presses to mean _different_ things depending on the state of the app (when you are focused on an input field, you may want to enter the letter `"j"` but when focused on a list of items, you may want to scroll down.)

Additionally, if any block of code takes a while to run, the app would block after pressing a key, which is not a pleasant user experience.
