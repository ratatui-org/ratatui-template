---
title: "`event.rs`"
---

Finally we get to the `EventHandler` code.

All terminal user interfaces need to have one main render loop like so:

```rust
fn main_render_loop()  {
  let th = TerminalHandler::new();
  th.enter();
  loop {
    th.terminal.draw(|f| render_app(f))?;
  }
  th.exit();
  Ok(())
}
```

While we are in the "raw mode", i.e. after we call `th.enter()`, any key presses in that terminal window are sent to `stdin`.
We have to read these key presses from `stdin` if we want to act on them.

There's a number of different ways to do that.
`crossterm` has a `event` module that implements features to read these key presses for us.

```rust
  fn main_render_loop(&mut self)  {
    let tui = TerminalHandler::new();
    loop {
      if event::poll(Duration::from_millis(250))? {
        if let Event::Key(key) = event::read()? {
          match key.code {
            KeyCode::Char('j') => self.increment(),
            KeyCode::Char('k') => self.decrement(),
            KeyCode::Char('q') => break,
            _ => (),
          }
        }
      };
      tui.terminal.draw(|f| render_app(f))?;
    }
    Ok(())
  }
```

This in my opinion conflates the key input handling with app state updates all in the draw loop.
The practical issue with this approach is we block the draw loop for 250ms waiting for a key press.
Pressing an holding a key will result in faster draws than waiting and doing nothing.

In terms of architecture, the code could get complicated to reason about.
For example, we may even want key presses to mean _different_ things depending on the state of the app (when you are focused on an input field, you may want to enter the letter `"j"` but when focused on a list of items, you may want to scroll down.)

In this section, I want to introduce the `EventHandler` struct:

```rust
use anyhow::Result;
use crossterm::{
  cursor,
  event::{DisableMouseCapture, EnableMouseCapture, Event as CrosstermEvent, KeyEvent, KeyEventKind, MouseEvent},
  terminal::{EnterAlternateScreen, LeaveAlternateScreen},
};
use futures::{FutureExt, StreamExt};
use tokio::{
  sync::{mpsc, oneshot},
  task::JoinHandle,
};

#[derive(Clone, Copy, Debug)]
pub enum Event {
  Quit,
  Error,
  Closed,
  RenderTick,
  AppTick,
  Key(KeyEvent),
  Mouse(MouseEvent),
  Resize(u16, u16),
}

#[derive(Debug)]
pub struct EventHandler {
  _tx: mpsc::UnboundedSender<Event>,
  rx: mpsc::UnboundedReceiver<Event>,
  stop_cancellation_token: CancellationToken,
  task: Option<JoinHandle<()>>,
}

impl EventHandler {
  pub fn new(app_tick_rate: u64, render_tick_rate: u64) -> Self {
    let app_tick_rate = std::time::Duration::from_millis(app_tick_rate);
    let render_tick_rate = std::time::Duration::from_millis(render_tick_rate);

    let (tx, rx) = mpsc::unbounded_channel();
    let _tx = tx.clone();

    let stop_cancellation_token = CancellationToken::new();
    let _stop_cancellation_token = stop_cancellation_token.clone();

    let task = tokio::spawn(async move {
      let mut reader = crossterm::event::EventStream::new();
      let mut app_interval = tokio::time::interval(app_tick_rate);
      let mut render_interval = tokio::time::interval(render_tick_rate);
      loop {
        let app_delay = app_interval.tick();
        let render_delay = render_interval.tick();
        let crossterm_event = reader.next().fuse();
        tokio::select! {
          _ = _stop_cancellation_token.cancelled() => {
            break;
          }
          maybe_event = crossterm_event => {
            match maybe_event {
              Some(Ok(evt)) => {
                match evt {
                  CrosstermEvent::Key(key) => {
                    if key.kind == KeyEventKind::Press {
                      tx.send(Event::Key(key)).unwrap();
                    }
                  },
                  CrosstermEvent::Resize(x, y) => {
                    tx.send(Event::Resize(x, y)).unwrap();
                  },
                  _ => {},
                }
              }
              Some(Err(_)) => {
                tx.send(Event::Error).unwrap();
              }
              None => {},
            }
          },
          _ = app_delay => {
              tx.send(Event::AppTick).unwrap();
          },
          _ = render_delay => {
              tx.send(Event::RenderTick).unwrap();
          },
        }
      }
    });

    Self { _tx, rx, stop_cancellation_token, task: Some(task) }
  }

  pub async fn next(&mut self) -> Option<Event> {
    self.rx.recv().await
  }

  pub async fn stop(&mut self) -> Result<()> {
    self.stop_cancellation_token.cancel();
    if let Some(handle) = self.task.take() {
      handle.await.unwrap();
    }
    Ok(())
  }
}
```

This struct spawns a tokio task, which does 3 things

1. Sends a `AppTick` event at every `app_tick_rate` interval
1. Sends a `RenderTick` event at every `render_tick_rate` interval
1. Sends a `Key` event whenever a key is pressed.

With this `EventHandler` implemented, we can use `tokio` to create a separate "task" that handles any key asynchronously in our `main` loop.

