---
title: "Refactoring basics"
---

Let's start with refactoring our program to a few different files.

1. `src/main.rs`:

This is our main file where the program begins execution. We're creating an instance of the `App` struct and running the application.

```rust
use anyhow::Result;
use ratatui_template::app::App;

fn main() -> Result<()> {
  let mut app = App::new(250)?; // 250 ms tick rate
  app.run().await?;
  Ok(())
}
```

2. `src/app.rs`:

This is the `App` module, which contains the core application logic.
It encapsulates application state and behavior, including event handling and rendering.
The `run` method manages the main event loop where inputs are processed and the UI is updated.
When 'q' is pressed, the application is set to quit.

```rust
use anyhow::Result;

use crate::terminal::{EventHandler, TerminalHandler};

pub struct App {
  pub tick_rate: u64,
  pub should_quit: bool,
}

impl App {
  pub fn new(tick_rate: u64) -> Result<Self> {
    Ok(Self { tick_rate, should_quit: false })
  }

  pub fn run(&mut self) -> Result<()> {
    let mut events = EventHandler::new(tick_rate);
    let mut tui = TerminalHandler::new()?;
    tui.enter()?;
    loop {

      tui.terminal.draw(|f| { self.render(f) })?;

      if let Some(event) = events.next() {
        match event {
          Event::Input(input) => {
            self.handle_input(input)?;
          }
          Event::Tick => {
            self.tick()?;
          }
          Event::Closed => {
            debug!("Event loop closed");
          }
        }
      }

      if self.should_quit {
        break;
      }
    }

    tui.exit()?;

    Ok(())
  }

  pub fn render(&mut self, f: &mut Frame<impl Backend>) {
    let rect = f.size();
    let greeting = Paragraph::new("Hello World! (press 'q' to quit)");
    f.render_widget(greeting, rect.size());
  }

  pub fn tick(&mut self) -> Result<()> {
    Ok(())
  }

  pub fn handle_input(&mut self, input: KeyCode) -> Result<()> {
    match input {
      KeyCode::Char('q') => self.should_quit = true
      _ => {}
    }
    Ok(())
  }

}
```

3. `src/terminal.rs`:

This section of the `terminal` module defines the `TerminalHandler` struct which is responsible for handling the terminal.
The new method constructs a new `TerminalHandler`.
The `enter` method sets the terminal into raw mode, enters the alternate screen, enables mouse capture, and hides the cursor.
The `exit` method does the opposite, showing the cursor, disabling mouse capture, leaving the alternate screen, and disabling raw mode.

```rust
use anyhow::Result;
use crossterm::{
  cursor,
  event::{DisableMouseCapture, EnableMouseCapture},
  terminal::{EnterAlternateScreen, LeaveAlternateScreen},
};
use ratatui::{backend::CrosstermBackend, terminal::Terminal, Frame as TuiFrame};

pub type Frame<'a> = TuiFrame<'a, CrosstermBackend<std::io::Stderr>>;

pub struct TerminalHandler {
  pub terminal: Terminal<CrosstermBackend<std::io::Stderr>>,
}

impl TerminalHandler {
  pub fn new() -> Result<Self> {
    let terminal = Terminal::new(CrosstermBackend::new(std::io::stderr()))?;
    Ok(Self { terminal })
  }

  pub fn enter(&self) -> Result<()> {
    crossterm::terminal::enable_raw_mode()?;
    crossterm::execute!(std::io::stderr(), EnterAlternateScreen, EnableMouseCapture, cursor::Hide)?;
    Ok(())
  }

  pub fn exit(&self) -> Result<()> {
    crossterm::execute!(std::io::stderr(), LeaveAlternateScreen, DisableMouseCapture, cursor::Show)?;
    crossterm::terminal::disable_raw_mode()?;
    Ok(())
  }
}
```

4. `src/event.rs`:

This is the `event` module, which abstracts the key event handling.
It implements the `EventHandler` struct that manages terminal events, including keystrokes, mouse events, and resizing.
Events are sent to a channel, which `App` can read from and react to.

```rust
use anyhow::Result;
use crossterm::event::{self, Event as CrosstermEvent, KeyEvent, MouseEvent};
use std::sync::mpsc;
use std::thread;
use std::time::{Duration, Instant};

#[derive(Clone, Copy, Debug)]
pub enum Event {
  Tick,
  Key(KeyEvent),
  Mouse(MouseEvent),
  Resize(u16, u16),
}

#[allow(dead_code)]
#[derive(Debug)]
pub struct EventHandler {
  sender: mpsc::Sender<Event>,
  receiver: mpsc::Receiver<Event>,
  handler: thread::JoinHandle<()>,
}

impl EventHandler {
  pub fn new(tick_rate: u64) -> Self {
    let tick_rate = Duration::from_millis(tick_rate);
    let (sender, receiver) = mpsc::channel();
    let handler = {
      let sender = sender.clone();
      thread::spawn(move || {
        let mut last_tick = Instant::now();
        loop {
          let timeout = tick_rate
            .checked_sub(last_tick.elapsed())
            .unwrap_or(tick_rate);

          if event::poll(timeout).expect("no events available") {
            match event::read().expect("unable to read event") {
              CrosstermEvent::Key(e) => sender.send(Event::Key(e)),
              CrosstermEvent::Mouse(e) => sender.send(Event::Mouse(e)),
              CrosstermEvent::Resize(w, h) => sender.send(Event::Resize(w, h)),
              _ => unimplemented!(),
            }
            .expect("failed to send terminal event")
          }

          if last_tick.elapsed() >= tick_rate {
            sender.send(Event::Tick).expect("failed to send tick event");
            last_tick = Instant::now();
          }
        }
      })
    };
    Self {
      sender,
      receiver,
      handler,
    }
  }

  pub fn next(&self) -> Result<Event> {
    Ok(self.receiver.recv()?)
  }
}
```

In this tutorial, we introduced the sending an `Event` over a channel using a separate thread.
This is essentially what is done in the official [`tui-rs-revival/rust-tui-template`](https://github.com/tui-rs-revival/rust-tui-template/tree/master/src).

In the next section, we'll introduce `tokio` to do the same thing.
